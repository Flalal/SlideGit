<!doctype html>
<html lang="fr">

    <head>
        <meta charset="utf-8">

        <title>Git</title>

        <meta name="description" content="Formation Git">
        <meta name="author" content="Gauthier C.">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="reveal.js/css/reveal.css">
        <link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
        <link rel="shortcut icon" href="./images/favicon.ico">
        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
        <style>
            .reveal h1 {
                text-transform: none;
            }
            .reveal h3 {
                text-transform: none;
            }
            .reveal h4 {
                text-transform: none;
            }
            #shell {
                color: #255a7c;
                font-family: Monospace;
                font-size: 0.8em;
            }
            .reveal thead {
                font-size: 0.85em;
            }
            .reveal td {
                font-size: 0.8em;
            }
            .reveal section img {
                background:none; border:none; box-shadow:none;
            }
            img[alt="minipic"] { 
                max-height:  80px;
                vertical-align: middle;
            }
            img[alt="titlepic"] { 
                max-height: 150px;
                vertical-align: top;
            }
            img[alt="maxpic"] { 
                max-height: 500px;
            }
        </style>
        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
        <!--[if lt IE 9]>
        <script src="reveal.js/lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
<section id="debut" >
    <img src="images/Git-Logo-2Color.png" style="background:none; border:none; box-shadow:none;width:60%;" />
    <!--<h1>Core<span style="color:#f35b69">O</span><span style="color:#6d9eeb">S</span></h1>-->
    <h3>Maitriser Git pour un usage au quotidien</h3>
    <p><small><small>
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Présentation </span> de <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"><a href="http://twitter.com/CattGr">@CattGr</a></span> est mise à disposition selon les termes de la <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">licence Creative Commons Attribution 4.0 International</a></small></small>
    </p>
</section>

<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<section>
    <section data-markdown id="Introduction">
    # Introduction
    </section>

        <section data-markdown id="apropos">
        ## À propos des gestionnaires de versions
        </section>

            <section data-markdown>
            ### Les systèmes de gestion de version locaux
            ![maxpic](images/local.png)
            </section>

            <section data-markdown>
            ### Les systèmes de gestion de version centralisés
            ![maxpic](images/centralized.png)
            </section>

            <section data-markdown>
            ### Les systèmes de gestion de version distribués
            ![maxpic](images/distributed.png)
            </section>

        <section data-markdown id="gitavantages">
        ## Git et ses avantages
        - vitesse ;
        - conception simple ;
        - support pour les développements non linéaires (milliers de branches parallèles) ;
        - complètement distribué ;
        - capacité à gérer efficacement des projets d’envergure tels que le noyau Linux (vitesse et compacité des données).
        </section>


        <section data-markdown id="rudiment">
        ## Rudiments de Git
        </section>

            <section data-markdown>
            ### Des instantanés, pas des différences
            Fonctionnement des VCS classiques (cvs, subversion, Perforce, Bazaar, ...)
            ![maxpic](images/deltas.png)
            </section>

            <section data-markdown>
            ### Des instantanés, pas des différences
            Fonctionnement de Git
            ![maxpic](images/snapshots.png)
            </section>

            <section data-markdown>
            ### Presque toutes les opérations sont locales
            - Fonctionne parfaitement en mode déconnecté.
            - Pas besoin de vpn pour travailler
            - Toutes les révisions sont présentes sur tout les dépôts.
            </section>

            <section data-markdown>
            ### Git gère l’intégrité
            - Vérification de l'intégrité des fichiers fait partie intégrante de la philosophie de l'outil.
            </section>

            <section data-markdown>
            ### Les trois états de vos fichiers
            ![maxpic](images/areas.png)
            </section>
</section>

<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<section>
    <section data-markdown id="avcom">
    # Avant de commencer
    </section>

            <section data-markdown>
            ### Paramétrage à la première utilisation
            - Fichier /etc/gitconfig : Tous les utilisateurs. *git config --system*
            - Fichier ~/.gitconfig : Spécifique à votre utilisateur. *git config --global*
            - Fichier config dans le répertoire Git (c’est-à-dire .git/config) : spécifique au seul dépôt en cours.
            </section>

            <section data-markdown>
            ### Votre identité
            - $ git config --global user.name "John Doe"
            - $ git config --global user.email johndoe@example.com
            </section>

            <section data-markdown>
            ### Votre éditeur de texte
            - $ git config --global core.editor vim
            </section>

            <section data-markdown>
            ### Vérifier vos paramètres
            ```
            $ git config --list
            user.name=John Doe
            user.email=johndoe@example.com
            color.status=auto
            color.branch=auto
            color.interactive=auto
            color.diff=auto
            …
            ```
            ```
            $ git config user.name
            John Doe
            ```
            </section>

            <section data-markdown>
            ### Obtenir de l'aide
            Si vous avez besoin d’aide pour utiliser Git, il y a trois moyens d’obtenir les pages de manuel pour toutes les commandes de Git :
            - $ git help *commande*
            - $ git *commande* --help
            - $ man git-*commande*
            </section>
            <section data-markdown>
            ### Exercice
            - Effectuez le paramêtrage de votre environnement Git avec *git config*
                - nom, email, editeur
            - Aidez vous de la commande git help
            </section>
</section>

<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<section>
    <section data-markdown id="cmdbase">
    # Les commandes de base
    </section>

        <section data-markdown>
        ## Démarrer un dépôt Git
        </section>
            <section data-markdown>
            ### Démarrage d'un dépôt Git local
            ```
            $ git init
            ```
            Cela crée un nouveau sous-répertoire nommé .git qui contient tous les fichiers nécessaires au dépôt.
            ```
            $ git add *.c
            $ git add LICENSE
            $ git commit -m 'initial project version'
            ```
            </section>
            <section data-markdown>
            ### Cloner un dépôt existant
            ```
            $ git clone https://github.com/libgit2/libgit2
            ```
            Ceci crée un répertoire nommé “libgit2”, initialise un répertoire .git à l’intérieur, récupère toutes les données de ce dépôt, et extrait une copie de travail de la dernière version.
            </section>
    
        <section data-markdown>
        ## Enregistrer des modifications dans le dépôt
        </section>
    
            <section data-markdown>
            ### Cycle de vie de vos fichiers
            ![maxpic](images/lifecycle.png)
            </section>

            <section data-markdown>
            ### Commandes de base
            - git status
            - git add
            - git diff
            - git commit
            - git rm
            - git mv
            ### Ignorer des fichiers
            - .gitignore
            </section>
            <section data-markdown>
            ### Exercice
            - Créez un nouveau dossier
            - Initialisez un nouveau dépôt Git dans ce dossier
            - Manipulez et faites des commits pour valider ces modifications avec les commandes suivantes:
                - git status
                - git add
                - git diff
                - git commit
                - git rm
                - git mv
            </section>
        <section data-markdown>
        ## Visualiser l’historique des validations
        - git log
        - git log -p -2
        - git log --stat
        - git log --pretty=oneline
        - git log --pretty=format:"%h - %an, %ar : %s"
        - git log --pretty=format:"%h %s" --graph
        - git log --since=2.weeks
        </section>
    
</section>
<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<section>
    <section data-markdown id="branches">
    # Les Branches
    </section>

        <section data-markdown id="benb">
        ## Les branches en bref
        - Une branche dans Git est simplement un pointeur léger et déplaçable vers un commits
        - *Master* est la branche par défaut créé par la commande *git init*
        </section>

            <section data-markdown>
            ### Une branche et l’historique de ses commits
            ![maxpic](images/branch-and-history.png)
            </section>

            <section data-markdown>
            ### Créer une nouvelle branche
            ```
            git branch testing
            ```
            Cela crée un nouveau pointeur vers le commit courant.
            ![maxpic](images/two-branches.png)
            </section>
            <section data-markdown>
            ### Vous êtes toujours sur la branche *master*.
            ![maxpic](images/head-to-master.png)
            </section>
            <section data-markdown>
            ### Changer de branche
            ```
            $ git checkout testing
            ```
            ![maxpic](images/head-to-testing.png)
            </section>
            <section data-markdown>
            ### Qu’est-ce que cela signifie ? 
            Et bien, faisons une autre validation :
            ```
            $ vim README.md
            $ git commit -a -m 'un changement dans le fichier README'
            ```
            ![maxpic](images/advance-testing.png)
            </section>
            <section data-markdown>
            ### Retournons sur la branche master
            ```
            $ git checkout master
            ```
            ![maxpic](images/checkout-master.png)
            </section>
            <section data-markdown>
            ### Nouvelle modification pour diverger
            ```
            $ vim README.md
            $ git commit -a -m 'un changement dans le fichier README'
            ```
            ![maxpic](images/advance-master.png)
            </section>
            <section data-markdown>
            ### Suppression d'une branche
            ```
            $ git branch -d testing
            ```
            </section>
            <section data-markdown>
            ### À retenir
            - 3 commandes: commit, branch, checkout
            - Une branche Git n’est en fait qu’un simple fichier contenant les 40 caractères de l’empreinte SHA-1 du commit sur lequel elle pointe.
            - *git log --oneline --decorate --graph --all* pour visualiser les branches.
            - Quand vous changez de branche, Git réinitialise votre répertoire de travail pour qu’il soit le même que la dernière fois que vous avez effectué un commit sur cette branche. 
            </section>
            <section data-markdown>
            ### Exercice
            - Créez 3 fichiers textes (fich1, fich2, fich3)
            - Créez une nouvelle branche appelée *dev*
            - Positionnez-vous sur la branche *dev*
            - Modifiez fich1 et faites un commit
            </section>
</section>
<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<section>

   <section data-markdown id="depotdistant">
   # Travailler avec des dépôts distants
   </section>

        <section data-markdown>
        ## Manipulation des dépôts distants
        </section>
            <section data-markdown>
            ### Afficher les dépôts distants
            ```
            $ git remote -v
            origin https://github.com/schacon/ticgit (fetch)
            origin https://github.com/schacon/ticgit (push)
            ```
            </section>

            <section data-markdown>
            ### Ajouter des dépôts distants
            ```
            $ git remote
            origin
            $ git remote add paul https://github.com/paulboone/ticgit
            $ git remote -v
            origin https://github.com/schacon/ticgit (fetch)
            origin https://github.com/schacon/ticgit (push)
            paul https://github.com/paulboone/ticgit (fetch)
            paul https://github.com/paulboone/ticgit (push)
            ```
            </section>
    
            <section data-markdown>
            ### Récupérer et tirer depuis des dépôts distants
            ```
            $ git fetch [remote-name]
            ```
            ### Pousser son travail sur un dépôt distant
            ```
            $ git push [nom-distant] [nom-de-branche]
            ```
            </section>
    
            <section data-markdown>
            ### Inspecter un dépôt distant
            ```
            $ git remote show origin
              * distante origin
              URL de rapatriement : https://github.com/schacon/ticgit
              URL push : https://github.com/schacon/ticgit
              Branche HEAD : master
              Branches distantes :
                master suivi
                ticgit suivi
              Branche locale configurée pour 'git pull' :
                master fusionne avec la distante master
              Référence locale configurée pour 'git push' :
                master pousse vers master (à jour)
            ```
            </section>
    
            <section data-markdown>
            ### Retirer et renommer des dépôts distants
            ```
            $ git remote rename paul paulboone
            $ git remote
            origin
            paulboone
            ```
            </section>
    
        <section data-markdown>
        ## Stockage des identifiants
        </section>
            <section data-markdown>
            ### SSH
            * Création d'un bi-clé
            * Dépôt de la clef publique sur le serveur
            * Charger la clef en mémoire avec ssh-add
            </section>
            <section data-markdown>
            ### Authentification HTTP
            Plusieurs modes proposés:
            * Par défaut, rien n’est mis en cache.
            * Le mode « cache » conserve en mémoire les identifiants pendant 15 minutes par défaut.
            ```
            git config --global credential.helper "cache --timeout 900"
            ```
            * Le mode « store » sauvegarde les identifiants dans un fichier texte (en clair) sur le disque, et celui-ci n’expire jamais.
            ```
            git config --global credential.helper "store --file ~/.my-credentials"
            ```
            </section>
            <section data-markdown>
            ### Authentification HTTP
            * Sous Mac, Git propose un mode « osxkeychain », qui met en cache les identifiants dans un trousseau sécurisé attaché à votre compte système.
            * Sous Windows, vous pouvez installer une application appelée « Git Credential Manager for Windows » similaire à « osxkeychain ».
            </section>
</section>

<section>
   <section data-markdown>
   # Étiquetage
   </section>
    
            <section data-markdown>
            ### Lister vos étiquettes
            Lister les étiquettes existantes dans Git est très simple. Tapez juste *git tag* :
            ```
            $ git tag
            v0.1
            v1.3
            ```
            Recherche avec un motif
            ```
            $ git tag -l 'v1.3.*'
            v1.3.1
            v1.3.2
            ```
            </section>
        
            <section data-markdown>
            ### Créer des étiquettes annotées
            ```
            $ git tag -a v1.4 -m 'ma version 1.4'
            $ git tag
            v1.3
            v1.4
            ```
            Vous pouvez visualiser les données de l’étiquette à côté du commit qui a été marqué en utilisant la commande *git show*
            </section>
        
            <section data-markdown>
            ### Les étiquettes légères
            Pour créer une étiquette légère, il suffit de n’utiliser aucune des options -a, -s ou -m :
            ```
            $ git tag v1.4-lg
            $ git tag
            v0.1
            v1.4
            v1.4-lg
            v1.5
            ```
            Regarder la différence de sortie avec *git show*.
            </section>
        
            <section data-markdown>
            ### Étiqueter après coup
            Pour étiqueter un ancien commit, vous spécifiez la somme de contrôle du commit (ou une partie) en fin de commande :
            ```
            $ git tag -a v1.2 9fceb02
            ```
            </section>
        
            <section data-markdown>
            ### Partager les étiquettes
            Par défaut, la commande git push ne transfère pas les étiquettes vers les serveurs distants. Il faut explicitement pousser les étiquettes après les avoir créées localement.
            ```
            $ git push origin v1.5
            ```
            La commande suivante transférera toutes les nouvelles étiquettes vers le serveur distant.
            ```
            $ git push origin --tags
            ```
            </section>
        
        <section data-markdown>
        ## Les alias Git
        Git ne complète pas votre commande si vous ne la tapez que partiellement. Si vous ne voulez pas avoir à taper l’intégralité du texte de chaque commande, vous pouvez facilement définir un alias pour chaque commande en utilisant git config. 
        ```
        $ git config --global alias.co checkout
        $ git config --global alias.br branch
        $ git config --global alias.ci commit
        $ git config --global alias.st status
        ```
        </section>
   
</section>

<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<section>
    <section data-markdown id="bfc">
    # Fusion et conflit
    </section>
        <section data-markdown id="fusion">
        ## Fusion
        </section>
            <section data-markdown>
            ### Merge Fast-forward
            ![maxpic](images/basic-branching-4.png)
            ```
            $ git checkout master
            $ git merge correctif
            Updating f42c576..3a0874c
            Fast-forward
             index.html | 2 ++
             1 file changed, 2 insertions(+)
            ```
            </section>
            <section data-markdown>
            ### Merge Fast-forward
            ![maxpic](images/basic-branching-5.png)
            </section>
            <section data-markdown>
            ### Exercice
            - Créez une nouvelle branche appelée *bugFix*
            - Positionnez-vous sur la branche *bugFix*
            - Modifiez un fichier et faites un commit
            - Retournez sur la branche master (commande *git checkout*)
            - Modifiez un fichier et faites un nouveau commit
            - Fusionnez la branche *bugFix* dans master avec *git merge*
            </section>
            <section data-markdown>
            ### Git Rebase
            La seconde façon de combiner les contenus de deux branches est rebase. Rebase prend un ensemble de commits, les "recopie", et les ajoute en bout de chaîne à un autre endroit.
            </section>
            <section data-markdown>
            ### Avant le Git Rebase
            ![maxpic](images/basic-rebase-1.png)
            </section>
            <section data-markdown>
            ### Après un Git merge
            Rappel, si l'on applique le *git merge* nous obtenons ceci:
            ![maxpic](images/basic-rebase-2.png)
            </section>
            <section data-markdown>
            ### Après le Git Rebase
            ![maxpic](images/basic-rebase-3.png)
            ```
            $ git checkout experiment
            $ git rebase master
            First, rewinding head to replay your work on top of it...
            Applying: added staged command
            ```
            </section>
            <section data-markdown>
            ### Résultat final
            À ce moment, vous pouvez retourner sur la branche master et réaliser une fusion en avance rapide (fast-forward merge) pour obtenir ceci:
            ![maxpic](images/basic-rebase-4.png)
            </section>
            <section data-markdown>
            ### À retenir
            - Toutes les modifications apparaissent en série même si elles ont eu lieu en parallèle.
            - Le commit résultant d'un merge ou d'un rebase est strictement identique.
            - Utile pour proposer un patch pour un projet que vous ne maintenez pas.
            - **Ne rebasez jamais des commits qui ont déjà été poussés sur un dépôt public.**
            </section>
            <section data-markdown>
            ### Exercice
            - Créez une nouvelle branche appelée *bugFix*
            - Positionnez-vous sur la branche *bugFix*
            - Modifiez un fichier et faites un commit
            - Retournez sur la branche master (commande *git checkout*)
            - Modifiez un fichier et faites un nouveau commit
            - Positionnez-vous sur la branche *bugFix* et faites un *git rebase master*
            </section>
        <section data-markdown id="conflit">
        ## Conflits de fusion
         Si vous avez modifié différemment la même partie du même fichier dans les deux branches que vous souhaitez fusionner, Git ne sera pas capable de réaliser proprement la fusion.
        </section>
            <section data-markdown>
            ### Merge avec conflit
            Si votre résolution du problème #53 a modifié la même section de fichier que le correctif, vous obtiendrez un conflit qui ressemblera à ceci :
            ```
            $ git merge prob53
            Fusion automatique de index.html
            CONFLIT (contenu) : Conflit de fusion dans index.html
            La fusion automatique a échoué ; réglez les conflits et validez le résultat.
            ```
            Git n’a pas automatiquement créé le commit de fusion. Il a arrêté le processus le temps que vous résolviez le conflit.
            </section>
            <section data-markdown>
            ### Verification de la liste des fichiers impactés
            ```
            $ git status
            Sur la branche master
            Vous avez des chemins non fusionnés.
              (réglez les conflits puis lancez "git commit")
              (use "git merge --abort" to abort the merge)
            
            Chemins non fusionnés :
              (utilisez "git add &lt;fichier&gt;..." pour marquer comme résolu)
            
                    modifié des deux côtés :  index.html
            
            aucune modification n'a été ajoutée à la validation (utilisez "git add" ou "git commit -a")
            ```
            </section>
            <section data-markdown>
            ### Correction du conflit à la main
            ```
            <<<<<<< HEAD:index.html
            &lt;div id="footer"&gt;contact : email.support@github.com&lt;/div&gt;
            =======
            &lt;div id="footer"&gt;
             please contact us at support@github.com
            &lt;/div&gt;
            >>>>>>> prob53:index.html
            ```
            C'est au développeur de prendre la décision et d'enregistrer le fichier. Ensuite *git add* et d'un *git commit* pour terminer l'opération.
            </section>
            <section data-markdown>
            ### Abandonner une fusion
            ```
            $ git merge --abort
            ```
            </section>
            <section data-markdown>
            ### Ignorer les caractères invisibles lors de la fusion
            ```
            $ git merge --Xignore-all-space mabranche
            ```
            ou
            ```
            $ git merge --Xignore-space-change mabranche
            ```
            La première option ignore complètement tous les espaces tandis que la seconde traite les séquences d’un ou plusieurs espaces comme équivalentes.
            </section>
            <section data-markdown>
            ### Défaire les fusions
            Avec Git il n’est pas interdit de faire des erreurs, parce qu’il reste toujours possible de les corriger.
            ```
            $ git reset --hard HEAD~
            ```
            **reset --hard** réalise généralement trois étapes :
            1. Déplace la branche pointée par HEAD,
            2. Faire ressembler l’index à HEAD,
            3. Faire ressembler le répertoire de travail à l’index.
            **À éviter après un push ou un autre commit.**
            </section>
            <section data-markdown>
            ### Inverser le commit
            Si les déplacements des pointeurs de branche ne sont pas envisageables, Git vous donne encore l’option de créer un nouveau commit qui défait toutes les modifications d’un autre déjà existant.
            ```
            $ git revert -m 1 HEAD
            ```
            L’option -m 1 indique quel parent est le principal et devrait être conservé.

            ** Attention, une nouvelle fusion ne donnera rien, car la branche a déjà été fusionnée.**
            </section>
</section>

<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<section>
    <section data-markdown id="interrupt">
    # Gérer les interruptions
    </section>
        <section data-markdown>
        ## Remisage et nettoyage
        </section>
            <section data-markdown>
            ### Remiser votre travail
            ```git stash``` *permet de remiser son travail.*

            ```git stash list``` *permet de lister les travaux remisés.*

            </section>
            <section data-markdown>
            ### Remisage créatif
            ``` git stash --keep-index```

            L'option ```--keep-index``` indique à Git de ne pas remiser ce qui aurait été déjà indexé au moyen de la commande ```git add```.
            </section>
            <section data-markdown>
            ### Défaire l'effet d'une remise
            Il n'existe pas de commande stash unapply.

            ```$ git stash show -p stash@{0} | git apply -R```

            Si la remise n’est pas indiquée, Git utilise la plus récente.
            </section>
            <section data-markdown>
            ### Créer une branche depuis une remise
            ```git stash branch teststash```

            C’est un bon raccourci pour récupérer facilement du travail remisé et pouvoir travailler dessus dans une nouvelle branche.
            </section>
            <section data-markdown>
            ### Nettoyer son espace de travail

            Enfin, vous pouvez ne pas souhaiter remiser certain fichiers de votre répertoire de travail, mais simplement vous en débarrasser. La commande ```git clean``` s’en chargera pour vous.

            Faites néanmoins très attention avec cette commande car elle supprime des fichiers non-suivis de votre répertoire de travail.
            </section>
</section>
<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<section>
    <section data-markdown id="bgc">
    # Bien gérer ses commits
    </section>
        <section data-markdown>
        ## Donner du sens au message de commit
        * Pour une meilleur lisibilité
        * Pour les nouveaux et les autres en général
        * Pour la revue de code
        </section>
            <section data-markdown>
            ### Conventions de commit
            * Exemple pour le projet angularjs

              &lt; **type** &gt; (&lt; **_scope_** &gt;): &lt; **Subject** &gt;
              
              &lt; *BLANK LINE* &gt;
              
              &lt; **_body_** &gt;
              
              &lt; *BLANK LINE* &gt;
              
              &lt; **_footer_** &gt;
            </section>
            <section data-markdown>
            &lt;**type**&gt; ( &lt; *scope* &gt; ): &lt; *Subject* &gt;
            * feat (feature)
            * fix (correction de bugs)
            * docs (documentation)
            * style (formatage, ponctuations manquantes, ...)
            * refactor
            * test (lors de l'ajout de tests manquants)
            * chore (maintenir)
            </section>
            <section data-markdown>
            &lt;*type*&gt; ( &lt; **scope** &gt; ): &lt; *Subject* &gt;

            Scope ou portée en français, indique la partie de code impactée par le changement.

            Il est important, avant de commencer le projet, de convenir d'une convention de nommage sur les différentes parties du programme.

            *Optionnel, une modification peut impacter la totalité du code.*
            </section>
            <section data-markdown>
            &lt;*type*&gt; ( &lt; *scope* &gt; ): &lt; **Subject** &gt;

            * Décrire ce que l'on apporte à l'application et non pas au code.
            * pas de majuscule sur la première lettre
            * pas de point (.) en fin de ligne
            </section>
            <section data-markdown>
            &lt; **_body_** &gt;

            * Complément du sujet
            * Détail de l'implémentation du changement

            *Optionnel*
            </section>
            <section data-markdown>
            &lt; **_footer_** &gt;
            * Référence sur le commit
            * Indication du numéro de bugfix
            * Indication des ruptures dans le code ( expliquer la migration, l'impact )

            *Optionnel*
            </section>
            <section data-markdown>
            #### Exemple
            ```
            fix($compile): couple of unit tests for IE9
            
            Older IEs serialize html uppercased, but IE9 does not...
            Would be better to expect case insensitive, unfortunately jasmine does
            not allow to user regexps for throw expectations.
            
            Closes #392
            Breaks foo.bar api, foo.baz should be used instead
            ```
            </section>
        <section data-markdown>
        ## Git add interactive
        </section>
            <section data-markdown>
            ### 
            </section>
            <section data-markdown>
            ### 
            </section>
            <section data-markdown>
            ### 
            </section>
</section>
<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<section>
   <section data-markdown>
   # Réécrire l'histoire
   </section>
        <section data-markdown>
        ## Annuler des actions
        </section>
    
            <section data-markdown>
            ### git commit --amend
            Remplace le commit précédent.
            ```
            $ git commit -m 'validation initiale'
            $ git add fichier_oublie
            $ git commit --amend
            ```
            Vous n’aurez au final qu’un unique commit — la seconde validation remplace le résultat de la première.
            </section>
  
            <section data-markdown>
            ### Désindexer un fichier déjà indexé
            ```
            $ git add .
            $ git status
            Sur la branche master
            Votre branche est à jour avec 'origin/master'.
            Modifications qui seront validées :
              (utilisez "git reset HEAD &lt;fichier&gt;..." pour désindexer)

                  renommé :   README.md -> README
                  modifié :   CONTRIBUTING.md
            ```
            La commande est rappelée lors du *git status*.
            ```
            $ git reset HEAD CONTRIBUTING.md
            Modifications non indexées après reset :
            M       CONTRIBUTING.md
            ```
            </section>

            <section data-markdown>
            ### Réinitialiser un fichier modifié
            *git status* nous indique comment procéder :
            ```
            Modifications qui ne seront pas validées :
              (utilisez "git add &lt;fichier&gt;..." pour mettre à jour ce qui sera validé)
                (utilisez "git checkout -- &lt;fichier&gt;..." pour annuler les modifications dans la copie de travail)

            ```
            ```
            $ git checkout -- CONTRIBUTING.md
            $ git status
            Sur la branche master
            Votre branche est à jour avec 'origin/master'.
            Modifications qui seront validées :
              (utilisez "git reset HEAD <fichier>..." pour désindexer)

                      renommé :         README.md -> README
            ```
            Vous pouvez constater que les modifications ont été annulées. (Danger!)
            </section>
</section>

<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<section>
    <section data-markdown id="workflowgit">
    # Git rebase interactif
    </section>

            <section data-markdown>
            ### Exercice
            - Effectuez 4 modifications dans vos fichiers avec 4 commits différents.
            - Utilisez la commande *git rebase* pour n'avoir qu'un seul commit pour ces 4 modifications.
            </section>
</section>
<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<section>
    <section data-markdown id="workflowgit">
    # Principaux Workflow Git
    </section>
            <section data-markdown>
            ### Gitflow
            </section>
</section>

<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<section>
    <section data-markdown id="plateform">
    # Les plate-formes d’hébergement de dépôts Git
    </section>
            <section data-markdown>
            ### Github
            </section>
            <section data-markdown>
            ### Bitbucket
            </section>
            <section data-markdown>
            ### Gitlab
            </section>
</section>

<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
<!-- ########################################################################################## -->
            </div>

        </div>

        <script src="reveal.js/lib/js/head.min.js"></script>
        <script src="reveal.js/js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'convex', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
                    { src: 'reveal.js/plugin/notes/notes.js', async: true }
                ]
            });

        </script>

    </body>
</html>
